#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>

#include <cuda_runtime.h>

#include <fstream>
#include <chrono>




__global__ void matrixMultiplication(const float *A, const float *B, float *C, int size) {
	
	int rowIdx = blockIdx.y * size + threadIdx.y;
	int colIdx = blockIdx.x * size + threadIdx.x;
	
	if(rowIdx < size && colIdx < size){
		
		float product = 0;

		for(int i = 0; i < size; i++){

			product += A[rowIdx * size + i] * B[i * size + colIddx];
		}
		
		C[rowIdx * size + colIdx] = product;
	}
}

inline cudaError_t checkCUDA(cudaError_t result){

	if(result != cudaSuccess){
	
	fprintf(stderr, "CUDA Runtime error: %s\n", cudaGetErrorString(result));
	assert(result == cudaSuccess);
	}	
	
	return result;
}


int main() {
	
	float* h_A, h_B, h_result;
	float* d_A, d_B, d_resulut;

	int numberOfElementsInDim = 10;
	int numberOfElemets = numberOElementsInDim*NumberOfElementsInDim;
	size_t size = numberOfElements * sizeof(float);

	std::ofstream save;
	std::ofstream save_managed;

	for(int i = 0; i < 100; i++){

		//classic mallocs
		h_A = static_cast<float*>(malloc(size));
		h_B = static_cast<float*>(malloc(size));
		h_result = static_cast<float*>(malloc(size));

		for(int j = 0; j < numberOfElements; i++){

			h_A[j] = static_cast<float>(rand())/RAND_MAX;
			h_B[j] = static_cast<float>(rand())/RAND_MAX;
		}

		checkCUDA(cudaMalloc((void**)&d_A, size));
		checkCUDA(cudaMalloc((void**)&d_B, size));
		checkCUDA(cudaMalloc((void**)&d_result, size));

		checkCUDA(cudaMemcpy(d_A, h_A, cudaMemcpyHostToDevice));

	}
	


	return 0;
}

